package bytecode;/**
 * Created by DELL on 2018/10/15.
 */

/**
 * user is lwb
 *
 * 构造器字节码：
 *  1.调用父类的构造器，构造器在调用时，方法名称为“父类.<init>":方法描述符。根据字节码可以看出，构造器方法中，第一句必须是调用父类构造器，要么隐式调用(调用默认构造器方法)，要么显示调用(如果父类没有默认构造器的情况下)。
 *  2.给实例字段进行初始化。这里的初始化，不是初始化默认值，而是给字段赋予在定义字段时候的值(putfield指令)，如果字段在定义时没有初始化，那么就没有相应的初始化操作，也就是没有相应的putfield指令的执行。这个阶段很像类加载阶段过程中的初始化阶段。
 *  3.执行构造器方法中的逻辑。如果定义构造器方法时，构造器方法体空，那么就没有相应的指令。
 *  注意：1.无论构造器方法体是否为空，上面的1和2都是会存在，而且如果一个类中定义了多个构造方法的话，2过程肯定时一样的，1过程会根据是否时显示/隐式调用存在一定的差别。
 *       2.构造方法的方法名在字节码中和类名是一样的，但是在调用构造方法时，使用的方法名全部都是<init>主要根据方法描述符来进行区分构造方法的重载。<init>方法可以理解成构造方法的总称。
 *       3.因为调用构造方法时，都要先调用父类构造方法<init>，可以的出，对子类字段进行初始化前，会现对父类字段进行初始化。
 *
 *  构造方法本质来说也是一个实例方法，应为他的调用，也是使用this实例来调用的，但是它是一个特殊的实例方法，特殊在，这个方法的方法名和类名是一样的，不遵循方法的命名规则，首字母小写，同时这个方法没有返回值，但是它却不用void进行修饰。
 *  所以这个方法的调用，不能调用普通实例方法那样进行调用。调用构造方法的方式：1.new关键字之后。2.在构造器方法中的第一句，使用this()/super()进行调用。3.使用反射中的newInstance方法调用。
 *
 *
 * 关于new关键字，根据生成的字节码，可以看出一种生成了三个字节码：new，dup，invokespecial，
 *  new指令：在堆空间中开辟一个空间，然后，给实例变量设置默认值，也就是相应类型的零值。这个过程很像类加载过程中的准备阶段一样，给类变量设置零值。
 *  dup：将new中生成的只有默认值的引用复制一份存放到栈顶中。
 *  invokespecial，调用相应的构造方法。
 *
 *  分配空间时的注意点：在分配空间时，根据java堆中的内存是否规整，也就是是不是使用的内存和未使用的内存没有混合在一起，如果规整，那么就是用一个指针来表示两者的边界，这种方式称为指针碰撞，
 *  当有内存被占用后，将这个指针向未使用区域移动一小段就可以了，如果堆中内存不规整的话，就不能使用指针碰撞这种方法了，使用一个空闲列表来进行记录那些内存没有被占用，如果有新的内存占用的话，
 *  就更新空闲列表。当内存分配完成之后，将内存中除了对象头占用的那段空间不值零外，其他的空间都置零。那么怎样知道对象头占用的空间，以及分配空间时，改分配多大空间呢？对象占用的空间在类加载完之后，就可以确定了，
 *  由此可见无论是采用指针碰撞还是空闲列表中的那种方式进行内存分配，在高并发的场景下创建对象，分配空间都会产生线程安全问题，
 *  导致指针指向不准或者空闲列表更新错误问题，为了解决高并发创建对象产生的问题，jvm采用了两种解决方案，
 *  1.采用cas并失败重试的方式更新指针或空闲列表，达到正确性，
 *  2.采用TLAB(Thread local allocation buffer)的方式，事先给每个线程在堆中分配一定的空间，这个线程创建的对象，就分配在堆给这个线程开辟的私有空间中，减少了线程之间的竞争。
 *
 *
 *
 *  类字段的初始化和实例字段初始化的差异和相同点：
 *      1.都是在给字段分配内存空间后，进行字段的零值初始化。
 *          对于类字段：在类的加载过程中类加载完成后会在内存中生成一个Class对象(也就是当前类的class对象，包含了当前类的元数据信息，也就是反射主要实现)
 *          在hotspot实现中，这个对象存放在方法区。准备阶段，会为每个类字段分配内存，分配完成后，给类字段赋予零值。
 *          对于实例字段：在利用new关键字创建一个对象时，产生的new指令，会在堆中为对象分配空间，然后对字段进行赋予零值。
 *      2.给字段赋予定义值。
 *          对于类字段：在类加载过程中的初始化阶段，将静态字段和静态代码块，组合到<cinit>方法中，然后调用。只有当类被主动调用时，才会执行初始化阶段。
 *          对于实例字段：在调用构造方法时完成，构造方法的调用过程参考上面”构造器字节码过程“
 *
 *
 *
 *
 **/


public class New {
    private int age=10;
    public New(int age){
        this.age = age;
    }

    /**
    上面构造器生成字节码如下：

    //调用父类构造器
     0: aload_0                            //取出第一个参数，也就是this，就是new指令产生没有初始化的那个引用。放到栈顶
     1: invokespecial #1                  // Method java/lang/Object."<init>":()V   //调用父类的构造器(一个实例方法)

     //初始化字段为定义的值 :类似于类加载过程中的初始化阶段。
     4: aload_0                           //取出this，放到栈顶
     5: bipush        10                  //初始化this中字段定义时候的值。
     7: putfield      #2                  // Field age:I

    //执行构造方法的逻辑
     10: aload_0
     11: iload_1
     12: putfield      #2                  // Field age:I
     15: return


     *
     *
     */

    public New(){
     //   System.out.println(this.age);
    }


    public static void main(String[] args){

       // new New();

        New new1 = new New(100);//赋值语句无非就是将值放入到局部变量new1在局部变量表指定的solt中，astore_1
        System.out.println(System.identityHashCode(new1));
        System.out.println(new1.hashCode());



    }

}
