/**
 * Created by DELL on 2018/10/19.
 *
 * 1.创建子类对象时，是否会创建父类对象？super是什么意思？
 *  不会创建父类对象。对象的创建只有调用了new指令才会分配空间创建对象，在创建子类对象时，调用了父类的构造方法，构造方法的作用仅仅是对对象进行初始化，并不会创建对象。
 *  在子类的字节码中，会有一个u2的类型的父类引用，属于CONSTANT_Class_info类型，通过这个类型可以找到父类中定义了那些方法和字段，这也就是super只能访问的方法和属性，
 *  在子类的内存布局中的实例数据部分，包含了父类的实例属性也包含了子类中定义的实例属性，而且各自存放在一起(父类和子类中的实例属性在实例区域的顺序主要取决于jvm的实现的分配策略，
 *  在hotspot中，默认情况下，在子对象内存布局的实例属性区域：父类字段在子类字段之前，如果为了节省内存开销的的话，开启了压缩分，子类中较窄的字段会插入到父类字段空隙中)
 *
 *  super和this一样是子类对象的引用，super的外观类型(静态类型)是父类类型，this的外观类型就是子类类型。
 *  当调用方法，对于super，使用的命令为invokeSpecial，有分派规则决定了，调用的就是父类的。
 *             而对于this，使用的则是invokeVirtual，进行静态分配后，还会进行动态分派，最终调用到子类的方法上，
 *  读/写字段是(权限允许的情况下)，访问的字段由外观类型决定，访问那个，而不是动态类型(静态类型)，当外观类型找不到的话，然后从父类中找，这就是字段的分派规则。
 *  super可以调用那些方法或属性字段，主要却决于子类字节码中u2的指定的父类类型
 *
 *  https://www.zhihu.com/question/51920553
 *
 *  同时也可以使用jmap来查看jvm进程中，创建的信息。jmap -histo pid；列出了jvm进程中类创建的对象的总数，占用的内存大小等。不会创建父类对象。
 *
 */
package bytecode;