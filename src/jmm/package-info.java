/**
 * Created by DELL on 2018/10/9.
 *
 * jmm指的是：java memory model,java内存模型，指的是JSR-133定义的规范和jvm内存结构是两个不同的概念(jvm的内存的划分组成)
 * jmm主要是为了简化多线程编程，保证程序可移植性问题，因为多线程程序的成功执行主要却决于处理器的架构，jmm主要就是帮助程序开发人员屏蔽
 * 底层cpu差异。进而实现程序的可移植性。
 * jmm是怎样屏蔽cpu差异对程序的影响的呢？
 *      因为不同的cpu在执行指令是，会采取一定的优化策略，通常就是指令重排，是程序更高效的执行，但是指令重排会影响程序执行的正确性(也就是可能不按照我们程序书写的顺序执行)
 *      jmm通常采用内存屏障（并不是jmm规范实现的唯一手段）来阻止执行重排序，通常内存屏障也提供了内存可见性。也就是实现了happen-before，如果a happen-before b(a和b分别在两个线程中执行)，
 *      那么b能看到a的变化。也就是a对b是可见的，所以happen-before不仅仅是时间次序，因为即使a时间上先执行，但是在其将结果从工作内存刷新主内存前，b操作在a执行后执行，也是看不到a产生的影响的。
 *      所以hanppen-before中的before是指：更新到主内存这个动作before在其他线程读取动作。
 *
 * jmm平衡了jvm工程师以及cpu工程师在性能上的需求和java程序员在简单性上的渴望，
 * 所以jmm在保证正确性的同时会最大限度的放宽对指令重排和乱序执行的限制
 *
 *
 *
 *
 */
package jmm;