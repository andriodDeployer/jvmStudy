/**
 * Created by DELL on 2018/10/9.
 *
 * jmm指的是：java memory model,java内存模型，指的是JSR-133定义的规范和jvm内存结构是两个不同的概念(jvm的内存的划分组成)
 * jmm主要是为了简化多线程编程，保证程序可移植性问题，因为多线程程序的成功执行主要却决于处理器的架构，jmm主要就是帮助程序开发人员屏蔽
 * 底层cpu差异。进而实现程序的可移植性。
 * jmm是怎样屏蔽cpu差异对程序的影响的呢？
 *      因为不同的cpu在执行指令是，会采取一定的优化策略，通常就是指令重排，是程序更高效的执行，但是指令重排会影响程序执行的正确性(也就是可能不按照我们程序书写的顺序执行)
 *      jmm通常采用内存屏障（并不是jmm规范实现的唯一手段）来阻止执行重排序，通常内存屏障也提供了内存可见性。也就是实现了happen-before，如果a happen-before b(a和b分别在两个线程中执行)，
 *      那么b能看到a的变化。也就是a对b是可见的，所以happen-before不仅仅是时间次序，因为即使a时间上先执行，但是在其将结果从工作内存刷新主内存前，b操作在a执行后执行，也是看不到a产生的影响的。
 *      所以hanppen-before中的before是指：更新到主内存这个动作before在其他线程读取动作。
 *
 * jmm平衡了jvm工程师以及cpu工程师在性能上的需求和java程序员在简单性上的渴望，
 * 所以jmm在保证正确性的同时会最大限度的放宽对指令重排和乱序执行的限制
 *
 *
 *
 *  在JMM中，即使A操作时钟上先行发生于B操作，那么B操作也不一定能够看到A操作的结果，因为B操作完之后，操作结果在B操作线程的工作内存中，什么时候将结果更新到主内存中是不固定的，
 *  即使时钟上后发生的B操作，也无法通过在主内存中看到A的操作结果。
 *  happen-before表达的是：如果A操作在时钟上先行发生于B操作，那么B操作就一定能够看到A操作的结果。
 *  happen-before的实现主要是依靠内存屏障，内存屏障有两个语义：1.防止指令重排的语义(针对即时编译器)，2将屏障前指令的操作结果从工作内存更新到主内存的语义(针对处理器)
 *  很显然happen-before使用的是内存屏障的第二个语义。
 *  关键字volatile关键字，使用了两个语义。实现了可见性，而且为了防止指令重排，在volatile修饰的变量的写操作前，读操作后，都会加入屏障，防止屏障前后的指令重排序。
 *
 *
 *  我们说的线程不安全，主要因为jmm模型中的工作内存和主内存中内存不一致造成的，换句话说，线程不安全问题之一就是可见性问题。happen-before就是为了结果可见性问题，
 *  而虚拟机实现的几个happen-before能够让开发者轻易的判断不同线程操作间的可见性。
 *  内存屏障防止指令重排序，虽然减少了多线程间的线程安全问题，但是对于即时编译器来说，他限制了重排序优化，对于处理器来说，它导致缓存刷新内存操作，增加了开销。
 *
 *
 *  as-if-serial语义：不管怎么重排序(重排序：主要为了充分利用多核处理器的并行处理的优势，将没有依赖关系指令并行执行，有可能在后面的指令先执行完了，或者为了优化执行将后面的指令放到前面来执行)
 *  在单线程环境下，执行结果不会发生改变。as-if-serial语义也是指令重排序优化的一个标准/红线。为了遵循as-if-serial语义，编译器和处理器不会对存在的数据依赖关系的操作做重排序。
 *  重排序虽然能提高效率，但是在多线程环境中，会出现一些诡异的问题-好像程序不是按照我们代码写的顺序执行的。为了结果这个问题有两种方法：1.迂回方式，既然重排序实现了as-if-serial语义，那么将多线程变成单线程执行-加锁/同步执行，同一时刻只能一个线程执行。
 *  2.直接杠，干扰指令重排序，采用内存屏障技术。
 *
 *
 *
 *
 *
 *
 *
 */
package jmm;