/**
 * Created by DELL on 2018/10/12.
 *
 * 用户态和内核态：
 *  用户态：通常指应用程序运行的环境。
 *  内核态：操作系统运行的环境，可以用来操作硬件设备。
 *  如果我们的应用程序需要操作内核态中的资源，比如关机操作，应用程序是无法直接做到的，需要通过内核态的操作系统完成，
 *  应用程序主要通过系统调用(系统调用：内核态给用户态开放的一个中断来实现的)向操作系统发送消息，来完成例如关机的操作。
 *  那么，在用户态的应用程序通过系统调用操作内核态中资源的过程，其实就涉及到了，用户态到内核态再到用户态的一个切换过程。
 *  用户态和内核态的切换过程相对只在用户态或只在内核态来说还是挺耗时的。
 *
 *synchronized在jdk1.6之前，很重，主要重在多次的用户态到内核态的切换上，
 *  1.由于synchronized使用底层os互斥量实现，获取锁(无论成功与否)会切换一次内核态，获取这个互斥量。
 *  2.当有竞争时，线程被挂起/阻塞，会涉及到用户态到内核态的一次切换。
 *  3.当释放锁时，会涉及到一次用户态和内核态的切换，当线程被唤醒时同样也会涉及到内核切换。
 *
 *  在1.6中对synchronized进行了优化，主要就是在减少用户态到内核态切换次数上下功夫。
 *  在没有锁竞争的情况下，获取锁是不需要使用到互斥量的，而是修改锁对象上的标记字段来表示对象获取到锁。
 *  只有在有竞争的情况下，才会使用到需要内核切换的重量级锁。
 *
 *  在1.6进行优化后，针对不同的情况(线程的个数多少，是否存在竞争)，对synchronized进行了不同的实现，实现的根本目的就是减少
 *  内核切换的次数。
 *  具体优化的的方式，主要对锁对象的标记字段(对象头的markword)来标记锁的状态。
 *  偏向锁：主要针对自始至终只有一个线程进入同步代码快的情况。不涉及到内核切换。
 *  轻量级锁：主要针对多个线程交替进入同步代码块(不存在重叠)的情况，具体工作流程：
 *      当进行加锁操作时，Java 虚拟机会判断是否已经是重量级锁。如果不是，它会在当前线程的当前栈
        桢中划出一块空间，作为该锁的锁记录，并且将锁对象的标记字段复制到该锁记录中。
        然后，Java 虚拟机会尝试用 CAS（compare-and-swap）操作替换锁对象的标记字段。这里解释
        一下，CAS 是一个原子操作，它会比较目标地址的值是否和期望值相等，如果相等，则替换为一个
        新的值。
        假设当前锁对象的标记字段为 X…XYZ，Java 虚拟机会比较该字段是否为 X…X01。如果是，则替换
        为刚才分配的锁记录的地址。由于内存对齐的缘故，它的最后两位为 00。此时，该线程已成功获得
        这把锁，可以继续执行了。
        如果不是 X…X01，那么有两种可能。第一，该线程重复获取同一把锁。此时，Java 虚拟机会将锁
        记录清零(清零前，当前栈帧锁记录的值为复制锁对象标记字段的值，也就四当前线程的地址，栈帧
        并不是该线程第一次获取锁的栈帧了，
        清零也不是清第一次获取锁的那个栈帧)，以代表该锁被重复获取。第二，其他线程持有该锁。此时，Java 虚拟机会将这把锁膨胀
        为重量级锁，并且阻塞当前线程。
        当进行解锁操作时，如果当前锁记录（你可以将一个线程的所有锁记录想象成一个栈结构，每次加
        锁压入一条锁记录，解锁弹出一条锁记录，当前锁记录指的便是栈顶的锁记录）的值为 0，则代表
        重复进入同一把锁，直接返回即可。
        否则，Java 虚拟机会尝试用 CAS 操作，比较锁对象的标记字段的值是否为当前锁记录的地址。如
        果是，则替换为锁记录中的值，也就是锁对象原本的标记字段。此时，该线程已经成功释放这把
        锁。
        如果不是，则意味着这把锁已经被膨胀为重量级锁。此时，Java 虚拟机会进入重量级锁的释放过
        程，唤醒因竞争该锁而被阻塞了的线程

 *
 *
 *
 *
 *
 */
package lock;