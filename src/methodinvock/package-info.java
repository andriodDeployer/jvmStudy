/**
 * Created by DELL on 2018/10/10.
 * 1.重载与重写：
 *  重载：在java程序中，如果一个类中，有多于一个方法名称相同，形式参数类型不同的方法的话，那么这几个方法之间就是重载关系，而在字节码中，重载的限制更少一些，在字节码文件中，
 *  方法名相同，形式参数或返回值不同就是重载。
 *  重载方法在编译期即可完成识别，所以重载方法的调用又称为静态绑定，java编译器会根据所传入的参数的声明类型(静态类型，而不是实际类型)，来选取重载方法，
 *  选取分为三个步骤：
 *      1.在不考虑自动装拆箱，不考虑变长参数的情况下选取重载方法，如果找不到适配方法，则进入第二步。如果找到多个进入第四步。
 *      2.考虑拆装箱，不考虑变长参数情况下选择重载方法，如果找不到适配方法，则进入第三步。如果找到多个进入第四步。
 *      3.同时考虑拆装箱和变长参数，如果找不到适配方法，则报错，如果找到多个进入第四步。
 *      4.在多个方法中找到一个最贴切的方法，贴切程度取决于形式参数的继承关系。如果父子类都适合的话，则选取子类型。
 *  在java语言中：如果子类中定义一个和父类中非私有方同名的方法，且方法的参数类型不同，那么在子类中，这两个方法同样构成重载。(对返回值类型不做限制)
 *
 *  在java语言中：如果子类中定义一个和父类中非私有方同名的方法，且方法的参数类型相同，如果方法是静态的，则子类覆盖了父类中的方法，
 *  如果不是静态的话，则构成重写。(对返回值类型不做限制)
 * 在jvm中确定一个方法的的条件主要包括：类名，方法名和方法描述符(方法的参数类型和方法的返回值类型)，在jvm进程中，每个方法都是唯一的。
 * 这样jvm可以根据三个条件能唯一确定一个方法。而且会在类加载过程验证阶段，对唯一性进行验证。
 *  在字节码中，如果子类定义了一个与父类中非私有，非静态的同名方法，且方法描述符相同，jvm认为是重写，比java程序要求更严格。
 *
 *
 *  分派：就是分配，确定一个方法。
 *  方法调用指令：
 *      invokestatic：调用静态方法：在解析阶段将符号引用解析为直接引用
 *      invokespecial：调用私有方法，构造方法，父类方法：在解析阶段完成解析。
 *      invokevirtual: 调用虚方法：在运行阶段完成解析
 *      invokeinterface: 调用接口方法：在运行阶段完成解析。
 *      invokedynamic: 调用动态方法
 *      对于上面的四种指令，jvm实现了分派逻辑(确定唯一方法的逻辑)，而对于invokedynamic的分派逻辑需要用户自己设定。
 *      对于invokestatic和invokespecial指定方法在类加载的解析阶段就可以唯一确定调用的方法，又称为解析调用。
 *      因为在解析阶段就把方法的符号引用解析为直接引用。这两个指令调用的方法称为非虚方法。
 *      其实对于无法被重写的方法都称为非虚方法，都可以在解析阶段完成解析。虽然final修饰的方法，是由invokevirtual指令执行，但是它确实非虚方法。
 *
 *
 *  静态分派：根据静态类型完成方法的分派。分派逻辑作用于方法的参数类型，根据传入参数的静态类型确定分派。确定某个类中的具体方法。
 *  动态分派：根据动态类型完成方法的分派。分派逻辑作用于方法的接收者类型。根据接收者的动态类型确定分派。确定调用的方法在那个类中，子类还是父类。
 *  通常方法的分派：先根据动态分派，确定方法在那个类中，然后在根据静态分派，确定这个类中具体那个方法
 *
 *
 *
 *
 */
package methodinvock;