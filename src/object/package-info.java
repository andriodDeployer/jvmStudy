/**
 * Created by DELL on 2018/10/18.
 *
 * 对象内部的组成：
 *  对象主要有三部分组成：对象头，实例数据，对齐填充。
 *      对象头：主要两部分构成：1.标记字段，主要用来存放对象的元数据信息，如对象的哈希码，年龄分代，锁标志等。标记字段占用的大小取决于操作系统的位数，如果操作系统是32位，那么标记字段就占用32byte，如果操作系统是64位，标记字段就占用64位。
 *                            2.类型指针，主要用来指向该对象所属的类(getClass(),就是获取执行该类类型的引用)，指针是数据在内存中起始地址的封装，所以指针要能寻址操作系统支持的内存大小，如果操作系统是64位，那么该操作系统支持的内存地址就是2^64byte，
 *                            那么指针要能定位2^64方位，指针占用的空间就是64位。
 *      实例数据，就是对象中实例字段占用的空间。
 *      对齐填充，为了是对象占用空间开始地址是8的倍数，要对占用空间不足8N的对象进行进行填充，填充的空间大小位8N-（对象头空间+实例字段空间+实例字段之间的填充）
 *
 *  由此可见对象要比基本类型占用的空间要大很多，那整形数据Integer和int比，在64位操作系统下，int占用4个字节，而Integer仅仅对象头就占用了128位，也就是16个字节了。
 *
 *
 *  伪共享(针对的共享变量，在多个线程之间可以被共享的变量，也就是存放在堆中的数据，volatile只能修饰共享变量):cpu的缓存系统(L3,L2,L1)是以缓存行为单位的,缓存行大小是2的整数幂个连续字节,一般为32-256个,最常见的缓存行大小为64.当我们操作一个小变量时,会将这个小变量以及和他地址相连的其他变量也加载进缓存行中,
 *  这种做法,对于连续访问地址相连的多个变量很高效,因为地址相连的其他变量已经在缓存行中,不用再从主内存中加载了,所以遍历数组效率相当高,而变量链表,就无法利用缓存行提供的缓存便利性了，每次访问节点都需要，从主内存中进行加载。
 *  但是缓存行也错在有弊端:伪共享.
 *      当两个线程(来自不同的core的情况下)访问类中独立的两个字段/变量时,这看似应该时互不影响,但是由于缓存行的原因，会将两个小变量加载进同一个缓存行中，因为L3缓存是多个core共享的，而L2和L1是每个core独占的，
 *      所以两个线程会将存在与L3中的缓存行，分别加载到各自的L2和L1中，当线程1修改了变量1，那么他就要将变量1的最新只更新到其自身的L1和L2中和共享的L3中，但是会不会写回主内存这个则不一定。
 *      如果写回主内存的话，将会使线程2所在core的L1和L2中缓存行都会失效，如果不写回主内存，则不会使core2的L1和L2失效。有的cpu会使L3也变得失效，那么就需要从主内存中获取。
 *      如果写回了主内存，使core2中数据失效的话，那么当线程2读取变量2的时候，需要从新从L3中将整个缓存行加载进L2和L1。如果此时线程2修改了变量2的话，同样线程1中的L1和L2中的缓存行也会变得无效，需要重新从L3更新数据，无形之中，连个独立的变量，变得相互影响了，
 *      对两个对立的变量的操作像是对同一个变量修改一样，产生了竞争。
 *  为了解决整个缓存行好心办坏事造成的伪共享问题，通常的做法就是缓存行填充，也就是在变量1的前后加上无意义的变量作为填充，这样当变量1加载进缓存行中后，同时会将无意义的变量也加载进去，占用缓存行中剩余的空间，
 *  当变量2加载进缓存行时，就会另外开辟一个新的缓存行，最终两个变量1和变量2分别占据着不同的缓存行，也就消除了伪共享的问题。
 *
 *  其实发生伪共享，也是需要满足一定的条件才可以的，要想使缓存行失效(core如何感知自己的缓存行失效的呢，这个需要一定的事件触发，他才会去判断，他不会一直定时的去和内存中进行比较的，太耗时了，core感知自己缓存行失效主要是经过嗅探cpu到内存之间的总线上传播的数据，
 *  如果总线上传播数据和自己缓存的数据地址一样但是值不一样的话，那么core就会让存放该数据的缓存行设置为无效，这是多处理器实现的一种缓存一致性协议)，必须让缓存行中的数据写到内存中，如果不写回内存中，即时其他core中缓存行中数据无效，其他core也是感知不到的，
 *  这也就是所谓的可见性问题了，对于普通的变量，对其值进行修改会，该变量的值不一定会理解写回到主内存中，其实也是为了效率，减少与主内存的交互，但是好心办成坏事，造成其他cpu缓存行中数据失效，产生可见性问题。
 *  如何让变量修改之后，立即更新到系统内存中呢？在inter处理器中，通过让core执行lock开头的指令，可以让该core的缓存行中的数据写回到系统内存，正是这个写回主内存的操作，让其他core中的缓存行无效，
 *  在java中实现Volatile关键字时，对于volatile变量创建/写操作时，生成的汇编代码会额外增加一个lock开头的命令，主要就是让volatile变量的更新，写会到主内存中。让其他core的缓存行失效，然后使用时从主内存中加载，实现了可见性。
 *  内存屏障是对lock开头的命令的一个封装，jvm通过在字节码中增加内存屏障，来完成在生成的汇编代码中添加lock开头的命令。
 *
 *  多处理器缓存一致性：当线程像缓存行写数据(就是cpu执行了更新操作)前，会先锁住要写的那个缓存行，此时其他线程是不能对包含相同数据的自己的缓存行进行访问的，也就是其他core也不能访问其字节的缓存行，直到写完成，
 *  写完成后，如果该缓存行中的数据，要写回到主内存中的话，则会引起其他core中缓存行失效。
 *
 *  我们上面说的伪共享，也就是当缓存行写入主内存时发生的，如果不发生写主内存，也就不会发生伪共享的问题，但是锁缓存的问题，总是会发生，
 *  所以伪共享的问题，通常时对volatile变量进行修改时才会发生。一般的变量进行修改之后，不会立即更新到主内存中，也就不会让其他core发觉缓存行失效，也就不会产生所谓的伪共享。
 *  使用缓存行填充不仅会解决伪共享的问题，还会解决锁缓存的问题(解决方案类似于ConcurrentHashMap中分成多个槽的解决思路)，如果不在一个缓存行的话，锁住变量1的缓存行，并不会影响变量2所在缓存行。
 *  减少了等待。
 *
 *  上面说的理论对java来说，可能会有一定的出入，毕竟java有jmm的存在：
 *      出入点：按照上面的理论，其实对于一般的变量也能实现可见性，因为当线程结束时，会将线程工作内存中的数据，写入到主内存，那么就会让其他缓存行就会失效，那么当在使用这个数据的时候，就需要从主内存中加载了，
 *      从而也就是实现可见行。
 *      但是当中间存在jmm时，可能就不是直接写主内存了，而是直接写线程工作内存了。从而使普通变量不存在可见性。即使写进了主内存，如果代码不从主内存中获取数据的话，而是从线程工作内存中获取的话，同样使无法获取到的最新的值的。
 *
 *
 *
 *
 * 缓存行填充的具体做法：
 *  在jdk6中：可直接在类中的字段前后7个long类型的字段(针对缓存行为64字节)，使对象/字段加上无意义的字段能填满缓存行。
 *  在jdk7中：编译器会优化掉无意义的填充字段，导致缓存行填充失败，解决这个问题，可以让填充字段放在父类中继承过来的无意义字段不会优化掉。
 *  在jdk8中：被jdk原生支持了，可以直接使用@Contended的注解，可以添加在类上也可以添加到字段上，让类/字段独占一个缓存行，需要注意的是，在运行时，必须加上虚拟机参数-XX:-RestrictContended之后，这个主机才会生效。
 *
 *
 *
 *
 *
 *
 *
 *  在JMM中工作内存指的就是缓存系统L1，L2和L3,堆/栈为主内存。
 *
 *
 *
 *  除此之外：为了提高执行效率，防止伪共享(多个字段占用一个内存行/一个字段跨两个内存行，如果一个字段进行了修改，那么这个字段占用的内存行就被修改了，也就是说这个内存行失效了，
 *  于这个字段共享内存行的其他字段，在内存行中的数据也就是失效了，如果要使用这个字段的话，需要将这个字段重新加载到内存行中)的产生，需要对字段进行内存对齐，让每个字段占用一个内存行，
 *  这样修改一个字段就不会影响其他字段的在内存行中失效。内存对齐会是空间产生很大的浪费，因为对齐的原因，让没有占满的内存会被浪费，
 *  为了减少(但不能避免)这种浪费，jvm会对对象中的字段在存储的时候，进行重排列，也就是对象在内存中存放的顺序和定义的顺序是不一样的，重排列主要就是减少内存对齐过程中的内存浪费，因为每个字段的偏移量(字段的其实地址相对于对象起始地址的差值，可以
 *  理解成字段在对象中的开始地址)，必须是字段占用空间的N倍。
 *  虽然字段重排序以及内存填充，可以减少虚共享的产生，但是无法避免，在java8中引入了一个新的注释@Contended,用来解决对象之间虚共享的产生，被标识的字段，会独占一个内存行，同时也会产生很大的内存浪费，这是空间换时间的使用。
 *  对象的起始地址必须是8N，在X86_64上，一个是为了让字段也能对齐，这样就不会出现字段横跨两个缓存行的情况，另一个原因更
    像个副作用，就是对象地址最后三位一直是0，JVM利用这个特性来实现压缩指针，也可以用这三位来记
    录一些额外信息。


    虚共享：如果两个字段占用了同一个缓存行的话，虽然这个两个字段是独立的，当两个线程同时修改两个字段中其中一个的话，由于两者共享了同一个缓存行，导致修改其中一个会影响另外一个，
    最终的导致的结果像是两个线程共享一个变量产生的结果一样。
 http://ifeve.com/falsesharing/
 *
 *
 *
 *
 */
package object;