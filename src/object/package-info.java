/**
 * Created by DELL on 2018/10/18.
 *
 * 对象内部的组成：
 *  对象主要有三部分组成：对象头，实例数据，对齐填充。
 *      对象头：主要两部分构成：1.标记字段，主要用来存放对象的元数据信息，如对象的哈希码，年龄分代，锁标志等。标记字段占用的大小取决于操作系统的位数，如果操作系统是32位，那么标记字段就占用32byte，如果操作系统是64位，标记字段就占用64位。
 *                            2.类型指针，主要用来指向该对象所属的类(getClass(),就是获取执行该类类型的引用)，指针是数据在内存中起始地址的封装，所以指针要能寻址操作系统支持的内存大小，如果操作系统是64位，那么该操作系统支持的内存地址就是2^64byte，
 *                            那么指针要能定位2^64方位，指针占用的空间就是64位。
 *      实例数据，就是对象中实例字段占用的空间。
 *      对齐填充，为了是对象占用空间开始地址是8的倍数，要对占用空间不足8N的对象进行进行填充，填充的空间大小位8N-（对象头空间+实例字段空间+实例字段之间的填充）
 *
 *  由此可见对象要比基本类型占用的空间要大很多，那整形数据Integer和int比，在64位操作系统下，int占用4个字节，而Integer仅仅对象头就占用了128位，也就是16个字节了。
 *
 *  除此之外：为了提高执行效率，防止伪共享(多个字段占用一个内存行/一个字段跨两个内存行，如果一个字段进行了修改，那么这个字段占用的内存行就被修改了，也就是说这个内存行失效了，
 *  于这个字段共享内存行的其他字段，在内存行中的数据也就是失效了，如果要使用这个字段的话，需要将这个字段重新加载到内存行中)的产生，需要对字段进行内存对齐，让每个字段占用一个内存行，
 *  这样修改一个字段就不会影响其他字段的在内存行中失效。内存对齐会是空间产生很大的浪费，因为对齐的原因，让没有占满的内存会被浪费，
 *  为了减少(但不能避免)这种浪费，jvm会对对象中的字段在存储的时候，进行重排列，也就是对象在内存中存放的顺序和定义的顺序是不一样的，重排列主要就是减少内存对齐过程中的内存浪费，因为每个字段的偏移量(字段的其实地址相对于对象起始地址的差值，可以
 *  理解成字段在对象中的开始地址)，必须是字段占用空间的N倍。
 *  虽然字段重排序以及内存填充，可以减少虚共享的产生，但是无法避免，在java8中引入了一个新的注释@Contended,用来解决对象之间虚共享的产生，被标识的字段，会独占一个内存行，同时也会产生很大的内存浪费，这是空间换时间的使用。
 *  对象的起始地址必须是8N，在X86_64上，一个是为了让字段也能对齐，这样就不会出现字段横跨两个缓存行的情况，另一个原因更
    像个副作用，就是对象地址最后三位一直是0，JVM利用这个特性来实现压缩指针，也可以用这三位来记
    录一些额外信息。


    虚共享：如果两个字段占用了同一个缓存行的话，虽然这个两个字段是独立的，当两个线程同时修改两个字段中其中一个的话，由于两者共享了同一个缓存行，导致修改其中一个会影响另外一个，
    最终的导致的结果像是两个线程共享一个变量产生的结果一样。
 http://ifeve.com/falsesharing/
 *
 *
 *
 *
 */
package object;